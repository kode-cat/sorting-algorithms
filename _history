{"entries":[{"timestamp":1745564529624,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":75,"length1":127,"diffs":[[1,"    algorithm: (values: number[]) => number[];\n    a?: number[];\n    place?: string;\n}\n"]]},{"start1":163,"length1":72,"diffs":[[1,"let currCount = 26;\nlet currentRun = 0;\n"]]},{"start1":204,"length1":80,"diffs":[[1,"let ySegment: number;\nlet currentPlace: number;\n"]]},{"start1":253,"length1":111,"diffs":[[1,"let running: SortingAlgorithm[] = [];\nlet notRunning: SortingAlgorithm[] = [];\n"]]},{"start1":333,"length1":429,"diffs":[[1,"addExample(\"selection sort\", sorts.selectionSort);\naddExample(\"insertion sort\", sorts.insertionSort);\naddExample(\"bubble sort\", sorts.bubbleSort);\naddExample(\"shell sort\", sorts.shellSort);\naddExample(\"heap sort\", sorts.heapSort);\naddExample(\"quick sort\", sorts.quickSort);\naddExample(\"merge sort\", sorts.mergeSort);\n"]]},{"start1":651,"length1":185,"diffs":[[1,"// Start off with two random algorithms running\nfor (let i = 0; i < 2; i++) {\n    moveRandom(notRunning, running);\n}\n"]]},{"start1":769,"length1":29,"diffs":[[1,"start();\n"]]},{"start1":779,"length1":309,"diffs":[[1,"game.onPaint(() => {\n    running.forEach(function (value: SortingAlgorithm, index: number) {\n        drawCurrentState(value, currCount, ySegment, index * ySegment);\n    });\n});\n"]]},{"start1":957,"length1":255,"diffs":[[1,"// start over with a new seed\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, () => {\n    start();\n});\n"]]},{"start1":1065,"length1":562,"diffs":[[1,"// remove a sorting algorithm from the group of running sorts\ncontroller.left.onEvent(ControllerButtonEvent.Pressed, () => {\n    if (running.length > 1) {\n        moveRandom(running, notRunning)\n        start();\n    }\n});\n"]]},{"start1":1288,"length1":719,"diffs":[[1,"// display a new sorting algorithm if possible\ncontroller.right.onEvent(ControllerButtonEvent.Pressed, () => {\n    if (notRunning.length > 0) {\n        moveRandom(notRunning, running)\n        start();\n    }\n});\n"]]},{"start1":1500,"length1":893,"diffs":[[1,"// increase the number of elements to sort if possible\ncontroller.up.onEvent(ControllerButtonEvent.Pressed, function () {\n    if (currCount + 6 < screen.width / 2) {\n        currCount += 6;\n        start();\n    }\n});\n"]]},{"start1":1718,"length1":1043,"diffs":[[1,"// decrease the number of elements to sort if possible\ncontroller.down.onEvent(ControllerButtonEvent.Pressed, function () {\n    if (currCount > 6) {\n        currCount -= 6;\n        start();\n    }\n})\n"]]},{"start1":1918,"length1":1024,"diffs":[[1,"function moveRandom<T>(a: T[], b: T[]) {\n    if (a.length > 0) {\n        const i = randint(0, a.length - 1);\n        b.push(a.removeAt(i));\n    }\n}\n"]]},{"start1":2067,"length1":1421,"diffs":[[1,"function addExample(title: string, sortAlgorithm: (values: number[]) => number[]) {\n    let output: SortingAlgorithm = {\n        title: title,\n        algorithm: sortAlgorithm\n    }\n    notRunning.push(output);\n}\n"]]},{"start1":2281,"length1":860,"diffs":[[1,"function start() {\n    const r = new Math.FastRandom();\n    ++currentRun;\n    currentPlace = 1;\n"]]},{"start1":2378,"length1":259,"diffs":[[1,"    ySegment = Math.floor(screen.height / running.length);\n"]]},{"start1":2438,"length1":1530,"diffs":[[1,"    // clear old arrays to quickly cull other threads as much as possible;\n    // only merge sort will survive as it is not in place\n    running.forEach(v => {\n        while (v.a && v.a.length != 0)\n            v.a.pop();\n    });\n"]]},{"start1":2669,"length1":650,"diffs":[[1,"    // create a new starting array for each of the algorithms\n    running.forEach(v => v.a = fillWithDefault(r, currCount, ySegment - (image.font5.charHeight + 2)));\n"]]},{"start1":2836,"length1":3538,"diffs":[[1,"    // run the comparison\n    running.forEach(v => control.runInParallel(() => {\n        const run = currentRun;\n        v.place = undefined;\n        v.algorithm(v.a);\n        if (run === currentRun) {\n            const place = currentPlace++;\n            if (place === 1)\n                music.powerUp.play();\n            else if (place === running.length)\n                music.wawawawaa.play();\n"]]},{"start1":3235,"length1":2022,"diffs":[[1,"            // ordinal indicator is 'st', 'nd', 'rd', or 'th'\n            v.place = place + ordinalIndicator(place);\n        }\n    }));\n}\n"]]},{"start1":3374,"length1":1764,"diffs":[[1,"function fillWithDefault(r: Math.FastRandom, count: number, maxHeight: number): number[] {\n    // reset seed so that output is consistent\n    r.reset();\n    let output: number[] = [];\n"]]},{"start1":3559,"length1":1322,"diffs":[[1,"    for (let i = 0; i < count; ++i) {\n        output.push(r.randomRange(0, maxHeight));\n    }\n"]]},{"start1":3654,"length1":865,"diffs":[[1,"    return output;\n}\n"]]},{"start1":3676,"length1":2418,"diffs":[[1,"function drawCurrentState(s: SortingAlgorithm, count: number, height: number, yOffset: number) {\n    const a = s.a\n    const title = s.title;\n    const lineWidth = Math.floor(screen.width / count) - 1;\n    const borderWidth = (screen.width - (count * (lineWidth + 1))) / 2;\n"]]},{"start1":3951,"length1":4169,"diffs":[[1,"    for (let i = 0; i < a.length; ++i) {\n        if (a[i] > 0) {\n            const maxValue = ySegment - (image.font5.charHeight + 2);\n            // pick color between 0x1 and 0xE based on value\n            let c = Math.clamp(0x1, 0xE, Math.floor(a[i] * 14 / maxValue));\n            screen.fillRect(borderWidth + i * (lineWidth + 1), height + yOffset - a[i], lineWidth, a[i], c);\n        }\n    }\n"]]},{"start1":4349,"length1":2264,"diffs":[[1,"    screen.print(title, borderWidth, yOffset + 1, 0x2, image.font5);\n    if (s.place)\n        screen.print(s.place, borderWidth, yOffset + 3 + image.font5.charHeight, 0x2, image.font5);\n}\n"]]},{"start1":4538,"length1":6309,"diffs":[[1,"function ordinalIndicator(input: number) {\n    const lastDigit = input % 10;\n    if (lastDigit === 1)\n        return \"st\";\n    else if (lastDigit === 2)\n        return \"nd\";\n    else if (lastDigit === 3)\n        return \"rd\";\n    else\n        return \"th\";\n}\n"]]},{"start1":4796,"length1":6134,"diffs":[[1,"/**\n * Sorting Algorithm Implementations\n */\nnamespace sorts {\n    function swap(a: number[], i: number, j: number) {\n        let tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n        pause(pauseDuration);\n    }\n"]]},{"start1":5016,"length1":2626,"diffs":[[1,"    function compare(a: number, b: number) {\n        pause(pauseDuration)\n        return a < b;\n    }\n"]]},{"start1":5119,"length1":7266,"diffs":[[1,"    export function insertionSort(a: number[]) {\n        for (let i = 0; i < a.length; i++) {\n            let value = a[i]\n            let j: number;\n            for (j = i - 1; j > -1 && compare(value, a[j]); --j) {\n                a[j + 1] = a[j];\n                pause(pauseDuration);\n            }\n            a[j + 1] = value;\n        }\n"]]},{"start1":5462,"length1":1548,"diffs":[[1,"        return a;\n    }\n"]]},{"start1":5487,"length1":11376,"diffs":[[1,"    export function selectionSort(a: number[]) {\n        for (let i = 0; i < a.length; i++) {\n            let min = i;\n            for (let j = i + 1; j < a.length; j++) {\n                if (compare(a[j], a[min])) {\n                    min = j;\n                    pause(pauseDuration);\n                }\n            }\n            if (i !== min) {\n                swap(a, i, min);\n            }\n        }\n"]]},{"start1":5894,"length1":1908,"diffs":[[1,"        return a;\n    }\n"]]},{"start1":5919,"length1":2999,"diffs":[[1,"    export function bubbleSort(a: number[]) {\n        for (let i = 0; i < a.length; ++i) {\n            for (let j = 0; j < i; ++j) {\n"]]},{"start1":6053,"length1":5158,"diffs":[[1,"                if (compare(a[i], a[j])) {\n                    swap(a, i, j);\n                }\n            }\n        }\n"]]},{"start1":6174,"length1":2124,"diffs":[[1,"        return a;\n    }\n"]]},{"start1":6199,"length1":6693,"diffs":[[1,"    export function shellSort(a: number[]) {\n        let increment = a.length / 2;\n        while (increment > 0) {\n            for (let i = increment; i < a.length; ++i) {\n                let j = i;\n                let t = a[i];\n"]]},{"start1":6429,"length1":8495,"diffs":[[1,"                while (j >= increment && compare(t, a[j - increment])) {\n                    a[j] = a[j - increment];\n                    j = j - increment;\n                    pause(pauseDuration);\n                }\n                a[j] = t;\n            }\n"]]},{"start1":6687,"length1":7826,"diffs":[[1,"            if (increment == 2) {\n                increment = 1;\n            } else {\n                increment = Math.floor(increment * 5 / 11);\n            }\n        }\n"]]},{"start1":6858,"length1":2668,"diffs":[[1,"        return a;\n    }\n"]]},{"start1":6883,"length1":4104,"diffs":[[1,"    export function quickSort(a: number[]) {\n        qsort(a, 0, a.length - 1);\n        return a;\n"]]},{"start1":6982,"length1":9947,"diffs":[[1,"        function qsort(a: number[], lo: number, hi: number) {\n            if (lo < hi) {\n                let p = partition(a, lo, hi);\n                qsort(a, lo, p - 1);\n                qsort(a, p + 1, hi);\n            }\n        }\n"]]},{"start1":7216,"length1":4467,"diffs":[[1,"        function partition(a: number[], lo: number, hi: number) {\n            let pivot = a[hi];\n            let i = lo - 1;\n"]]},{"start1":7342,"length1":9240,"diffs":[[1,"            for (let j = lo; compare(j, hi); ++j) {\n                if (a[j] < pivot) {\n                    i++;\n                    swap(a, i, j);\n                }\n            }\n"]]},{"start1":7523,"length1":6406,"diffs":[[1,"            swap(a, i + 1, hi);\n            return i + 1;\n        }\n    }\n"]]},{"start1":7598,"length1":4961,"diffs":[[1,"    export function heapSort(a: number[]) {\n        function buildMaxHeap(a: number[]) {\n            let i = Math.floor(a.length / 2 - 1);\n"]]},{"start1":7738,"length1":8388,"diffs":[[1,"            while (i >= 0) {\n                heapify(a, i, a.length);\n                i -= 1;\n            }\n        }\n"]]},{"start1":7857,"length1":8773,"diffs":[[1,"        function heapify(heap: number[], i: number, max: number) {\n            while (i < max) {\n                const left = 2 * i + 1;\n                const right = left + 1;\n                let curr = i;\n"]]},{"start1":8065,"length1":5446,"diffs":[[1,"                if (left < max && compare(heap[curr], heap[left])) {\n                    curr = left;\n                }\n"]]},{"start1":8186,"length1":5605,"diffs":[[1,"                if (right < max && compare(heap[curr], heap[right])) {\n                    curr = right;\n                }\n"]]},{"start1":8310,"length1":1901,"diffs":[[1,"                if (curr == i) return;\n"]]},{"start1":8350,"length1":9646,"diffs":[[1,"                swap(heap, i, curr);\n                i = curr;\n            }\n        }\n        buildMaxHeap(a);\n"]]},{"start1":8463,"length1":7928,"diffs":[[1,"        for (let i = a.length - 1; i > 0; --i) {\n            swap(a, 0, i);\n            heapify(a, 0, i);\n        }\n"]]},{"start1":8580,"length1":3988,"diffs":[[1,"        return a;\n    }\n"]]},{"start1":8605,"length1":18684,"diffs":[[1,"    export function mergeSort(a: number[]) {\n        // Typically, you wouldn't keep an 'offset' or a link to the 'original' array,\n        // as the sort works by returning a new, sorted array as output - not by modifying\n        // the one passed as input. Here, though, it is needed so that the preview on the\n        // screen can be updated\n        function msort(a: number[], offset: number, original: number[]): number[] {\n            if (a.length < 2) {\n                return a;\n            }\n"]]},{"start1":9108,"length1":2127,"diffs":[[1,"            const middle = Math.floor(a.length / 2);\n"]]},{"start1":9162,"length1":4278,"diffs":[[1,"            let left = a.slice(0, middle);\n            let right = a.slice(middle, a.length);\n"]]},{"start1":9257,"length1":4343,"diffs":[[1,"            left = msort(left, offset, original);\n            right = msort(right, offset + middle, original);\n"]]},{"start1":9369,"length1":2181,"diffs":[[1,"            const merged = merge(left, right);\n"]]},{"start1":9417,"length1":11075,"diffs":[[1,"            // Update preview on screen\n            merged.forEach(function (value: number, index: number) {\n                original[offset + index] = value;\n                pause(pauseDuration);\n            });\n"]]},{"start1":9631,"length1":4477,"diffs":[[1,"            return merged;\n        }\n"]]},{"start1":9669,"length1":9139,"diffs":[[1,"        function merge(left: number[], right: number[]) {\n            let result = [];\n            let lIndex = 0;\n            let rIndex = 0;\n"]]},{"start1":9813,"length1":46669,"diffs":[[1,"            while (lIndex < left.length && rIndex < right.length) {\n                if (compare(left[lIndex], right[rIndex])) {\n                    result.push(left[lIndex]);\n                    ++lIndex;\n                } else {\n                    result.push(right[rIndex]);\n                    ++rIndex;\n                }\n            }\n            while (lIndex < left.length) {\n                result.push(left[lIndex]);\n                ++lIndex;\n            }\n            while (rIndex < right.length) {\n                result.push(right[rIndex]);\n                ++rIndex;\n            }\n            return result;\n        }\n"]]},{"start1":10445,"length1":5169,"diffs":[[1,"        return msort(a, 0, a);\n    }\n"]]},{"start1":10483,"length1":23705,"diffs":[[1,"    export function isSorted(a: number[]) {\n        for (let i = 1; i < a.length; ++i) {\n            if (a[i - 1] > a[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n}"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":194,"length1":115,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1745564529623,"editorVersion":"2.0.53","text":{"main.ts":"const pauseDuration = 10;\n\ninterface SortingAlgorithm {\n    title: string;\n    algorithm: (values: number[]) => number[];\n    a?: number[];\n    place?: string;\n}\n\nlet currCount = 26;\nlet currentRun = 0;\n\nlet ySegment: number;\nlet currentPlace: number;\n\nlet running: SortingAlgorithm[] = [];\nlet notRunning: SortingAlgorithm[] = [];\n\naddExample(\"selection sort\", sorts.selectionSort);\naddExample(\"insertion sort\", sorts.insertionSort);\naddExample(\"bubble sort\", sorts.bubbleSort);\naddExample(\"shell sort\", sorts.shellSort);\naddExample(\"heap sort\", sorts.heapSort);\naddExample(\"quick sort\", sorts.quickSort);\naddExample(\"merge sort\", sorts.mergeSort);\n\n// Start off with two random algorithms running\nfor (let i = 0; i < 2; i++) {\n    moveRandom(notRunning, running);\n}\n\nstart();\n\ngame.onPaint(() => {\n    running.forEach(function (value: SortingAlgorithm, index: number) {\n        drawCurrentState(value, currCount, ySegment, index * ySegment);\n    });\n});\n\n// start over with a new seed\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, () => {\n    start();\n});\n\n// remove a sorting algorithm from the group of running sorts\ncontroller.left.onEvent(ControllerButtonEvent.Pressed, () => {\n    if (running.length > 1) {\n        moveRandom(running, notRunning)\n        start();\n    }\n});\n\n// display a new sorting algorithm if possible\ncontroller.right.onEvent(ControllerButtonEvent.Pressed, () => {\n    if (notRunning.length > 0) {\n        moveRandom(notRunning, running)\n        start();\n    }\n});\n\n// increase the number of elements to sort if possible\ncontroller.up.onEvent(ControllerButtonEvent.Pressed, function () {\n    if (currCount + 6 < screen.width / 2) {\n        currCount += 6;\n        start();\n    }\n});\n\n// decrease the number of elements to sort if possible\ncontroller.down.onEvent(ControllerButtonEvent.Pressed, function () {\n    if (currCount > 6) {\n        currCount -= 6;\n        start();\n    }\n})\n\nfunction moveRandom<T>(a: T[], b: T[]) {\n    if (a.length > 0) {\n        const i = randint(0, a.length - 1);\n        b.push(a.removeAt(i));\n    }\n}\n\nfunction addExample(title: string, sortAlgorithm: (values: number[]) => number[]) {\n    let output: SortingAlgorithm = {\n        title: title,\n        algorithm: sortAlgorithm\n    }\n    notRunning.push(output);\n}\n\nfunction start() {\n    const r = new Math.FastRandom();\n    ++currentRun;\n    currentPlace = 1;\n\n    ySegment = Math.floor(screen.height / running.length);\n\n    // clear old arrays to quickly cull other threads as much as possible;\n    // only merge sort will survive as it is not in place\n    running.forEach(v => {\n        while (v.a && v.a.length != 0)\n            v.a.pop();\n    });\n\n    // create a new starting array for each of the algorithms\n    running.forEach(v => v.a = fillWithDefault(r, currCount, ySegment - (image.font5.charHeight + 2)));\n\n    // run the comparison\n    running.forEach(v => control.runInParallel(() => {\n        const run = currentRun;\n        v.place = undefined;\n        v.algorithm(v.a);\n        if (run === currentRun) {\n            const place = currentPlace++;\n            if (place === 1)\n                music.powerUp.play();\n            else if (place === running.length)\n                music.wawawawaa.play();\n\n            // ordinal indicator is 'st', 'nd', 'rd', or 'th'\n            v.place = place + ordinalIndicator(place);\n        }\n    }));\n}\n\nfunction fillWithDefault(r: Math.FastRandom, count: number, maxHeight: number): number[] {\n    // reset seed so that output is consistent\n    r.reset();\n    let output: number[] = [];\n\n    for (let i = 0; i < count; ++i) {\n        output.push(r.randomRange(0, maxHeight));\n    }\n\n    return output;\n}\n\nfunction drawCurrentState(s: SortingAlgorithm, count: number, height: number, yOffset: number) {\n    const a = s.a\n    const title = s.title;\n    const lineWidth = Math.floor(screen.width / count) - 1;\n    const borderWidth = (screen.width - (count * (lineWidth + 1))) / 2;\n\n    for (let i = 0; i < a.length; ++i) {\n        if (a[i] > 0) {\n            const maxValue = ySegment - (image.font5.charHeight + 2);\n            // pick color between 0x1 and 0xE based on value\n            let c = Math.clamp(0x1, 0xE, Math.floor(a[i] * 14 / maxValue));\n            screen.fillRect(borderWidth + i * (lineWidth + 1), height + yOffset - a[i], lineWidth, a[i], c);\n        }\n    }\n\n    screen.print(title, borderWidth, yOffset + 1, 0x2, image.font5);\n    if (s.place)\n        screen.print(s.place, borderWidth, yOffset + 3 + image.font5.charHeight, 0x2, image.font5);\n}\n\nfunction ordinalIndicator(input: number) {\n    const lastDigit = input % 10;\n    if (lastDigit === 1)\n        return \"st\";\n    else if (lastDigit === 2)\n        return \"nd\";\n    else if (lastDigit === 3)\n        return \"rd\";\n    else\n        return \"th\";\n}\n\n/**\n * Sorting Algorithm Implementations\n */\nnamespace sorts {\n    function swap(a: number[], i: number, j: number) {\n        let tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n        pause(pauseDuration);\n    }\n\n    function compare(a: number, b: number) {\n        pause(pauseDuration)\n        return a < b;\n    }\n\n    export function insertionSort(a: number[]) {\n        for (let i = 0; i < a.length; i++) {\n            let value = a[i]\n            let j: number;\n            for (j = i - 1; j > -1 && compare(value, a[j]); --j) {\n                a[j + 1] = a[j];\n                pause(pauseDuration);\n            }\n            a[j + 1] = value;\n        }\n\n        return a;\n    }\n\n    export function selectionSort(a: number[]) {\n        for (let i = 0; i < a.length; i++) {\n            let min = i;\n            for (let j = i + 1; j < a.length; j++) {\n                if (compare(a[j], a[min])) {\n                    min = j;\n                    pause(pauseDuration);\n                }\n            }\n            if (i !== min) {\n                swap(a, i, min);\n            }\n        }\n\n        return a;\n    }\n\n    export function bubbleSort(a: number[]) {\n        for (let i = 0; i < a.length; ++i) {\n            for (let j = 0; j < i; ++j) {\n\n                if (compare(a[i], a[j])) {\n                    swap(a, i, j);\n                }\n            }\n        }\n\n        return a;\n    }\n\n    export function shellSort(a: number[]) {\n        let increment = a.length / 2;\n        while (increment > 0) {\n            for (let i = increment; i < a.length; ++i) {\n                let j = i;\n                let t = a[i];\n\n                while (j >= increment && compare(t, a[j - increment])) {\n                    a[j] = a[j - increment];\n                    j = j - increment;\n                    pause(pauseDuration);\n                }\n                a[j] = t;\n            }\n\n            if (increment == 2) {\n                increment = 1;\n            } else {\n                increment = Math.floor(increment * 5 / 11);\n            }\n        }\n\n        return a;\n    }\n\n    export function quickSort(a: number[]) {\n        qsort(a, 0, a.length - 1);\n        return a;\n\n        function qsort(a: number[], lo: number, hi: number) {\n            if (lo < hi) {\n                let p = partition(a, lo, hi);\n                qsort(a, lo, p - 1);\n                qsort(a, p + 1, hi);\n            }\n        }\n\n        function partition(a: number[], lo: number, hi: number) {\n            let pivot = a[hi];\n            let i = lo - 1;\n\n            for (let j = lo; compare(j, hi); ++j) {\n                if (a[j] < pivot) {\n                    i++;\n                    swap(a, i, j);\n                }\n            }\n\n            swap(a, i + 1, hi);\n            return i + 1;\n        }\n    }\n\n    export function heapSort(a: number[]) {\n        function buildMaxHeap(a: number[]) {\n            let i = Math.floor(a.length / 2 - 1);\n\n            while (i >= 0) {\n                heapify(a, i, a.length);\n                i -= 1;\n            }\n        }\n\n        function heapify(heap: number[], i: number, max: number) {\n            while (i < max) {\n                const left = 2 * i + 1;\n                const right = left + 1;\n                let curr = i;\n\n                if (left < max && compare(heap[curr], heap[left])) {\n                    curr = left;\n                }\n\n                if (right < max && compare(heap[curr], heap[right])) {\n                    curr = right;\n                }\n\n                if (curr == i) return;\n\n                swap(heap, i, curr);\n                i = curr;\n            }\n        }\n        buildMaxHeap(a);\n\n        for (let i = a.length - 1; i > 0; --i) {\n            swap(a, 0, i);\n            heapify(a, 0, i);\n        }\n\n        return a;\n    }\n\n    export function mergeSort(a: number[]) {\n        // Typically, you wouldn't keep an 'offset' or a link to the 'original' array,\n        // as the sort works by returning a new, sorted array as output - not by modifying\n        // the one passed as input. Here, though, it is needed so that the preview on the\n        // screen can be updated\n        function msort(a: number[], offset: number, original: number[]): number[] {\n            if (a.length < 2) {\n                return a;\n            }\n\n            const middle = Math.floor(a.length / 2);\n\n            let left = a.slice(0, middle);\n            let right = a.slice(middle, a.length);\n\n            left = msort(left, offset, original);\n            right = msort(right, offset + middle, original);\n\n            const merged = merge(left, right);\n\n            // Update preview on screen\n            merged.forEach(function (value: number, index: number) {\n                original[offset + index] = value;\n                pause(pauseDuration);\n            });\n\n            return merged;\n        }\n\n        function merge(left: number[], right: number[]) {\n            let result = [];\n            let lIndex = 0;\n            let rIndex = 0;\n\n            while (lIndex < left.length && rIndex < right.length) {\n                if (compare(left[lIndex], right[rIndex])) {\n                    result.push(left[lIndex]);\n                    ++lIndex;\n                } else {\n                    result.push(right[rIndex]);\n                    ++rIndex;\n                }\n            }\n            while (lIndex < left.length) {\n                result.push(left[lIndex]);\n                ++lIndex;\n            }\n            while (rIndex < right.length) {\n                result.push(right[rIndex]);\n                ++rIndex;\n            }\n            return result;\n        }\n\n        return msort(a, 0, a);\n    }\n\n    export function isSorted(a: number[]) {\n        for (let i = 1; i < a.length; ++i) {\n            if (a[i - 1] > a[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"sorting algorithms\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1745564890240}